--
-- PARALLEL
--
create or replace function parallel_restricted(int) returns int as
  $$begin return $1; end$$ language plpgsql parallel restricted;
-- Serializable isolation would disable parallel query, so explicitly use an
-- arbitrary other level.
begin isolation level repeatable read;
-- encourage use of parallel plans
set parallel_setup_cost=0;
set parallel_tuple_cost=0;
set min_parallel_relation_size=0;
set max_parallel_workers_per_gather=4;
explain (costs off)
  select count(*) from a_star;
                     QUERY PLAN                      
-----------------------------------------------------
 Finalize Aggregate
   ->  Gather
         Workers Planned: 1
         ->  Partial Aggregate
               ->  Append
                     ->  Parallel Seq Scan on a_star
                     ->  Parallel Seq Scan on b_star
                     ->  Parallel Seq Scan on c_star
                     ->  Parallel Seq Scan on d_star
                     ->  Parallel Seq Scan on e_star
                     ->  Parallel Seq Scan on f_star
(11 rows)

select count(*) from a_star;
 count 
-------
    50
(1 row)

-- test that parallel_restricted function doesn't run in worker
alter table tenk1 set (parallel_workers = 4);
explain (verbose, costs off)
select parallel_restricted(unique1) from tenk1
  where stringu1 = 'GRAAAA' order by 1;
                       QUERY PLAN                        
---------------------------------------------------------
 Sort
   Output: (parallel_restricted(unique1))
   Sort Key: (parallel_restricted(tenk1.unique1))
   ->  Gather
         Output: parallel_restricted(unique1)
         Workers Planned: 4
         ->  Parallel Seq Scan on public.tenk1
               Output: unique1
               Filter: (tenk1.stringu1 = 'GRAAAA'::name)
(9 rows)

-- test parallel plan when group by expression is in target list.
explain (costs off)
	select length(stringu1) from tenk1 group by length(stringu1);
                    QUERY PLAN                     
---------------------------------------------------
 Finalize HashAggregate
   Group Key: (length((stringu1)::text))
   ->  Gather
         Workers Planned: 4
         ->  Partial HashAggregate
               Group Key: length((stringu1)::text)
               ->  Parallel Seq Scan on tenk1
(7 rows)

select length(stringu1) from tenk1 group by length(stringu1);
 length 
--------
      6
(1 row)

explain (costs off)
	select stringu1, count(*) from tenk1 group by stringu1 order by stringu1;
                     QUERY PLAN                     
----------------------------------------------------
 Sort
   Sort Key: stringu1
   ->  Finalize HashAggregate
         Group Key: stringu1
         ->  Gather
               Workers Planned: 4
               ->  Partial HashAggregate
                     Group Key: stringu1
                     ->  Parallel Seq Scan on tenk1
(9 rows)

-- test that parallel plan for aggregates is not selected when
-- target list contains parallel restricted clause.
explain (costs off)
	select  sum(parallel_restricted(unique1)) from tenk1
	group by(parallel_restricted(unique1));
                     QUERY PLAN                     
----------------------------------------------------
 HashAggregate
   Group Key: parallel_restricted(unique1)
   ->  Index Only Scan using tenk1_unique1 on tenk1
(3 rows)

-- check parallelized int8 aggregate (bug #14897)
explain (costs off)
select avg(aa::int8) from a_star;
                     QUERY PLAN                      
-----------------------------------------------------
 Finalize Aggregate
   ->  Gather
         Workers Planned: 1
         ->  Partial Aggregate
               ->  Append
                     ->  Parallel Seq Scan on a_star
                     ->  Parallel Seq Scan on b_star
                     ->  Parallel Seq Scan on c_star
                     ->  Parallel Seq Scan on d_star
                     ->  Parallel Seq Scan on e_star
                     ->  Parallel Seq Scan on f_star
(11 rows)

select avg(aa::int8) from a_star;
         avg         
---------------------
 13.6538461538461538
(1 row)

-- test accumulation of stats for parallel nodes
set enable_indexscan to off;
set enable_bitmapscan to off;
set enable_material to off;
alter table tenk2 set (parallel_workers = 0);
create function explain_parallel_stats() returns setof text
language plpgsql as
$$
declare ln text;
begin
    for ln in
        explain (analyze, timing off, costs off)
          select count(*) from tenk1, tenk2 where
            tenk1.hundred > 1 and tenk2.thousand=0
    loop
        ln := regexp_replace(ln, 'Planning time: \S*',  'Planning time: xxx');
        ln := regexp_replace(ln, 'Execution time: \S*', 'Execution time: xxx');
        return next ln;
    end loop;
end;
$$;
select * from explain_parallel_stats();
                          explain_parallel_stats                          
--------------------------------------------------------------------------
 Aggregate (actual rows=1 loops=1)
   ->  Nested Loop (actual rows=98000 loops=1)
         ->  Seq Scan on tenk2 (actual rows=10 loops=1)
               Filter: (thousand = 0)
               Rows Removed by Filter: 9990
         ->  Gather (actual rows=9800 loops=10)
               Workers Planned: 4
               Workers Launched: 4
               ->  Parallel Seq Scan on tenk1 (actual rows=1960 loops=50)
                     Filter: (hundred > 1)
                     Rows Removed by Filter: 40
 Planning time: xxx ms
 Execution time: xxx ms
(13 rows)

reset enable_indexscan;
reset enable_bitmapscan;
reset enable_material;
alter table tenk2 reset (parallel_workers);
drop function explain_parallel_stats();
-- test the sanity of parallel query after the active role is dropped.
set force_parallel_mode=1;
drop role if exists regress_parallel_worker;
NOTICE:  role "regress_parallel_worker" does not exist, skipping
create role regress_parallel_worker;
set role regress_parallel_worker;
reset session authorization;
drop role regress_parallel_worker;
select count(*) from tenk1;
 count 
-------
 10000
(1 row)

reset role;
-- Window function calculation can't be pushed to workers.
explain (costs off, verbose)
  select count(*) from tenk1 a where (unique1, two) in
    (select unique1, row_number() over() from tenk1 b);
                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 Aggregate
   Output: count(*)
   ->  Hash Semi Join
         Hash Cond: ((a.unique1 = b.unique1) AND (a.two = (row_number() OVER (?))))
         ->  Gather
               Output: a.unique1, a.two
               Workers Planned: 4
               ->  Parallel Seq Scan on public.tenk1 a
                     Output: a.unique1, a.two
         ->  Hash
               Output: b.unique1, (row_number() OVER (?))
               ->  WindowAgg
                     Output: b.unique1, row_number() OVER (?)
                     ->  Index Only Scan using tenk1_unique1 on public.tenk1 b
                           Output: b.unique1
(15 rows)

-- LIMIT/OFFSET within sub-selects can't be pushed to workers.
explain (costs off)
  select * from tenk1 a where two in
    (select two from tenk1 b where stringu1 like '%AAAA' limit 3);
                          QUERY PLAN                           
---------------------------------------------------------------
 Hash Semi Join
   Hash Cond: (a.two = b.two)
   ->  Gather
         Workers Planned: 4
         ->  Parallel Seq Scan on tenk1 a
   ->  Hash
         ->  Limit
               ->  Gather
                     Workers Planned: 4
                     ->  Parallel Seq Scan on tenk1 b
                           Filter: (stringu1 ~~ '%AAAA'::text)
(11 rows)

explain (costs off)
  select stringu1::int2 from tenk1 where unique1 = 1;
                  QUERY PLAN                   
-----------------------------------------------
 Gather
   Workers Planned: 1
   Single Copy: true
   ->  Index Scan using tenk1_unique1 on tenk1
         Index Cond: (unique1 = 1)
(5 rows)

-- test passing expanded-value representations to workers
CREATE FUNCTION make_some_array(int,int) returns int[] as
$$declare x int[];
  begin
    x[1] := $1;
    x[2] := $2;
    return x;
  end$$ language plpgsql parallel safe;
CREATE TABLE fooarr(f1 text, f2 int[], f3 text);
INSERT INTO fooarr VALUES('1', ARRAY[1,2], 'one');
PREPARE pstmt(text, int[]) AS SELECT * FROM fooarr WHERE f1 = $1 AND f2 = $2;
EXPLAIN (COSTS OFF) EXECUTE pstmt('1', make_some_array(1,2));
                            QUERY PLAN                            
------------------------------------------------------------------
 Gather
   Workers Planned: 3
   ->  Parallel Seq Scan on fooarr
         Filter: ((f1 = '1'::text) AND (f2 = '{1,2}'::integer[]))
(4 rows)

EXECUTE pstmt('1', make_some_array(1,2));
 f1 |  f2   | f3  
----+-------+-----
 1  | {1,2} | one
(1 row)

DEALLOCATE pstmt;
do $$begin
  -- Provoke error, possibly in worker.  If this error happens to occur in
  -- the worker, there will be a CONTEXT line which must be hidden.
  perform stringu1::int2 from tenk1 where unique1 = 1;
  exception
	when others then
		raise 'SQLERRM: %', sqlerrm;
end$$;
ERROR:  SQLERRM: invalid input syntax for integer: "BAAAAA"
CONTEXT:  PL/pgSQL function inline_code_block line 7 at RAISE
rollback;
